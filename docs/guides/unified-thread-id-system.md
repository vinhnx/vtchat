# Unified Thread ID System with Legid

## Overview

VTChat uses a unified thread ID generation system based on [legid](https://github.com/shuding/legid) for secure, URL-compatible thread identifiers. This system provides both synchronous and asynchronous ID generation while maintaining security and verification capabilities.

## Key Features

- **Security**: legid generates IDs that are difficult to manipulate or predict
- **URL-Safe**: All generated IDs are compatible with URLs and file systems
- **Verification**: Server-side verification without extra network requests
- **Performance**: Pre-generated ID pool for immediate synchronous access
- **Migration Support**: Handles legacy nanoid/uuid IDs during transition

## Implementation

### Core Files

- [`packages/shared/lib/thread-id.ts`](../packages/shared/lib/thread-id.ts) - Main thread ID generation and validation
- [`apps/web/app/chat/[threadId]/page.tsx`](../apps/web/app/chat/[threadId]/page.tsx) - Thread route handling
- [`packages/common/store/chat.store.ts`](../packages/common/store/chat.store.ts) - Thread creation and management

### ID Generation

```typescript
// Async generation (preferred for server-side)
const threadId = await generateThreadId();

// Sync generation (uses pre-generated pool)
const threadId = generateThreadIdSync();
```

### ID Validation

```typescript
// Verify legid-generated ID
const isValid = await verifyThreadId(id);

// Check if ID is legacy format
const isLegacy = isLegacyThreadId(id);

// Check if ID is temporary fallback
const isTemp = isTemporaryThreadId(id);
```

### LegidPool System

The system uses a `LegidPool` class that:

1. **Pre-generates** 10 legid IDs for immediate synchronous access
2. **Auto-refills** the pool when it gets low (< 3 IDs)
3. **Fallback protection** with temporary IDs if pool is exhausted
4. **Background processing** for pool maintenance

## ID Types

### 1. Legid IDs (Current Standard)

- Format: `dYQLdJQ5nm` (10 characters, URL-safe)
- Secure, verifiable, and manipulation-resistant
- Generated by legid library

### 2. Legacy IDs (Migration Support)

- **Nanoid**: `a1b2c3d4e5f6g7h8i9j0k` (21 characters)
- **UUID**: `123e4567-e89b-12d3-a456-426614174000` (36 characters)
- Still supported for existing threads

### 3. Temporary IDs (Rare Fallback)

- Format: `tmp_abc123_xyz789`
- Only used if legid pool is exhausted (should never happen)
- Automatically replaced with proper legid IDs

## Route Handling

### Thread Route: `/chat/[threadId]`

The route handles all ID types:

1. **ID Extraction**: Gets threadId from URL parameters
2. **Database Lookup**: Validates thread exists via `getThread(threadId)`
3. **Redirect on Invalid**: Redirects to `/` if thread doesn't exist
4. **Thread Switching**: Updates chat store with valid thread

### Middleware

- Basic `/chat` â†’ `/` redirect (exact path only)
- No thread ID validation in middleware (handled in component)
- Preserves `/chat/[threadId]` routes

## Performance

### Test Results

- **Async Generation**: ~0ms for 10 IDs
- **Sync Generation**: ~0ms for 10 IDs (from pool)
- **Verification**: Fast server-side validation
- **Pool Efficiency**: Maintains 10 pre-generated IDs

### Benefits

- **Zero Network Overhead**: No API calls for ID generation
- **Immediate Availability**: Sync IDs available instantly
- **Background Refill**: Pool maintained without blocking UI
- **Fallback Safety**: Temporary IDs prevent failures

## Migration Strategy

### Legacy ID Support

The system maintains backward compatibility:

1. **Detection**: `isLegacyThreadId()` identifies old formats
2. **Database**: All ID types work with existing database
3. **Verification**: Legacy IDs skip legid verification
4. **Migration Tools**: Available for bulk conversion

### Transition Process

1. **Current**: Mixed legid/legacy IDs in database
2. **New Threads**: Always use legid
3. **Existing Threads**: Continue working with legacy IDs
4. **Future**: Optional migration to convert all legacy IDs

## Security Considerations

### Legid Security Model

- **Not Cryptographic**: legid is not a cryptographic solution
- **Manipulation Resistant**: Difficult to predict or modify IDs
- **Salt Protection**: Uses SHA-1 hash with salt prefix
- **Client-Safe**: Can be generated on client without security risk

### Production Recommendations

- **Server Verification**: Always verify IDs on sensitive operations
- **Rate Limiting**: Apply rate limits to ID generation endpoints
- **Monitoring**: Log suspicious ID manipulation attempts
- **Backup Validation**: Use database existence as final validation

## Troubleshooting

### Common Issues

1. **Pool Exhaustion**: Check for excessive sync ID generation
2. **Verification Failures**: Ensure same salt used client/server
3. **Route Errors**: Verify thread exists in database
4. **Migration Issues**: Use provided migration tools

### Debug Tools

```typescript
// Check ID type and validity
const id = 'dYQLdJQ5nm';
console.log({
    isValid: await verifyThreadId(id),
    isLegacy: isLegacyThreadId(id),
    isTemp: isTemporaryThreadId(id),
});
```

## Best Practices

1. **Use Async When Possible**: Prefer `generateThreadId()` on server
2. **Verify Important Operations**: Always verify IDs for sensitive actions
3. **Handle Legacy IDs**: Support both legid and legacy formats
4. **Monitor Pool Health**: Watch for pool exhaustion in production
5. **Database Validation**: Use existence checks as final validation

## Future Improvements

- **Custom Salt Configuration**: Environment-specific salts
- **Pool Size Tuning**: Adjust pool size based on usage patterns
- **Metrics Collection**: Track ID generation and verification stats
- **Migration Automation**: Tools for bulk legacy ID conversion
